package xyz.hyffer.onemessage_server.client_api.service;

import io.hypersistence.utils.hibernate.query.SQLExtractor;
import jakarta.annotation.Resource;
import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import org.hibernate.query.sqm.tree.domain.SqmBasicValuedSimplePath;
import org.hibernate.query.sqm.tree.expression.ValueBindJpaCriteriaParameter;
import org.hibernate.query.sqm.tree.predicate.SqmComparisonPredicate;
import org.hibernate.query.sqm.tree.predicate.SqmJunctionPredicate;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.logicng.formulas.CType;
import org.logicng.formulas.Formula;
import org.logicng.formulas.FormulaFactory;
import org.logicng.io.parsers.ParserException;
import org.logicng.io.parsers.PseudoBooleanParser;
import org.mockito.ArgumentCaptor;
import org.mockito.ArgumentMatchers;
import org.mockito.Captor;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.StringUtils;
import xyz.hyffer.onemessage_server.model.Contact;
import xyz.hyffer.onemessage_server.model.Contact_;
import xyz.hyffer.onemessage_server.storage.ContactRepository;

import java.util.Map;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

/**
 * Unit test for {@link ClientCustomQuery}
 * <p>
 * This is a unit test checking whether {@link ClientCustomQuery} can build query correctly.
 * However, to get JPA Metamodel generator working, and to get `entityManager` for testing,
 * it is launched with `@DataJpaTest` annotation.
 */
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
public class ClientCustomQueryTest {

    @Resource
    EntityManager entityManager;

    ClientCustomQuery clientCustomQuery;

    ContactRepository contactRepository;

    @Captor
    ArgumentCaptor<Specification<Contact>> arg1;
    @Captor
    ArgumentCaptor<Pageable> arg2;

    @BeforeEach
    void setupMock() {
        contactRepository = mock(ContactRepository.class);
        given(contactRepository.findAll(ArgumentMatchers.<Specification<Contact>>any(), any(Pageable.class)))
                .willReturn(Page.empty());

        clientCustomQuery = new ClientCustomQuery(contactRepository);
    }

    FormulaFactory ff = new FormulaFactory();
    PseudoBooleanParser pp = new PseudoBooleanParser(ff);

    /**
     * Construct a {@link Formula} from given {@link Predicate}
     *
     * @param predicate generated by {@link Specification#toPredicate(Root, CriteriaQuery, CriteriaBuilder)}
     * @return pseudo boolean formula
     */
    Formula constructFromPredicate(Predicate predicate) {
        if (predicate instanceof SqmJunctionPredicate p) {
            // compound predicate
            Formula lhs = constructFromPredicate(p.getPredicates().get(0));
            Formula rhs = constructFromPredicate(p.getPredicates().get(1));
            String op = p.getOperator().name().toLowerCase();   // "and" or "or"
            return ReflectionTestUtils.invokeMethod(ff, op, (Object) new Formula[]{lhs, rhs});

        } else if (predicate instanceof SqmComparisonPredicate p) {
            // simple predicate
            CType op;
            boolean negated = p.isNegated();
            switch (p.getSqmOperator()) {
                case EQUAL -> op = CType.EQ;
                case NOT_EQUAL -> {
                    op = CType.EQ;
                    negated = !negated;
                }
                case GREATER_THAN -> op = CType.GT;
                case GREATER_THAN_OR_EQUAL -> op = CType.GE;
                case LESS_THAN -> op = CType.LT;
                case LESS_THAN_OR_EQUAL -> op = CType.LE;
                default -> throw new RuntimeException("Not implement yet");
            }
            SqmBasicValuedSimplePath<?> lhs;
            ValueBindJpaCriteriaParameter<?> rhs;
            if (p.getLeftHandExpression() instanceof SqmBasicValuedSimplePath<?> l
                    && p.getRightHandExpression() instanceof ValueBindJpaCriteriaParameter<?> r) {
                lhs = l;
                rhs = r;
            } else if (p.getLeftHandExpression() instanceof ValueBindJpaCriteriaParameter<?> l
                    && p.getRightHandExpression() instanceof SqmBasicValuedSimplePath<?> r) {
                // swap lhs and rhs
                lhs = r;
                rhs = l;
                Map<CType, CType> reverse = Map.of(
                        CType.GT, CType.LT,
                        CType.GE, CType.LE,
                        CType.LT, CType.GT,
                        CType.LE, CType.GE
                );
                if (reverse.containsKey(op))
                    op = reverse.get(op);
            } else {
                throw new RuntimeException("Not implement yet");
            }

            String variable;    // field name
            Integer value;      // value
            variable = lhs.getNavigablePath().getLocalName();
            if (!(rhs.getValue() instanceof Integer)) {
                throw new RuntimeException("Not implement yet");
            }
            value = (Integer) rhs.getValue();
            assert value != null;
            Formula formula = ff.cc(op, value, ff.variable(variable));
            if (negated)
                formula = ff.not(formula);
            return formula;

        } else {
            throw new RuntimeException("Not implement yet");
        }
    }

    /**
     * Check SQL string
     */
    interface SQLChecker {
        void check(String sql);
    }

    /**
     * Check whether correct parameters are passed to {@link JpaSpecificationExecutor#findAll(Specification, Pageable)}.
     * Parameters are captured by {@link #arg1} and {@link #arg2}
     *
     * @param f       a formula string representing the expected predicate
     * @param checker functor to check SQL generated by the specification
     * @param limit   expected page size, must be positive.
     *                or null representing no paging
     * @param sort    expected sort order. {@link Sort#unsorted()} or null representing no sorting
     */
    void checkParams(String f, SQLChecker checker, Integer limit, Sort sort) {
        Specification<Contact> specification = arg1.getValue();
        Pageable pageable = arg2.getValue();

        // check specification
        CriteriaBuilder builder = entityManager.getCriteriaBuilder();
        CriteriaQuery<Contact> query = builder.createQuery(Contact.class);
        Root<Contact> root = query.from(Contact.class);
        Predicate predicate = specification.toPredicate(root, query, builder);

        // construct formula from specification, and compare with expected
        Formula formula = constructFromPredicate(predicate);
        Formula formula_expected;
        try {
            formula_expected = pp.parse(f);
        } catch (ParserException e) {
            throw new RuntimeException(e);
        }
        assertThat(formula).isEqualTo(formula_expected);

        // check specification by generated SQL
        if (checker != null) {
            query.where(predicate);
            TypedQuery<Contact> q = entityManager.createQuery(query);
            String sql = SQLExtractor.from(q);
            checker.check(sql);
        }

        // check pageable
        assert limit == null || limit > 0;
        if (limit == null) {
            assertTrue(pageable.isUnpaged());
        } else {
            assertThat(pageable.getPageSize()).isEqualTo(limit);
            assertThat(pageable.getPageNumber()).isEqualTo(0);
        }

        if (sort == null) {
            assertTrue(pageable.getSort().isUnsorted());
        } else {
            assertThat(pageable.getSort()).isEqualTo(sort);
        }
    }

    @Test
    void catchupContacts_case1() {
        clientCustomQuery.catchupContacts(35, null, null, null, 15);
        verify(contactRepository).findAll(arg1.capture(), arg2.capture());
        checkParams(
                "_CID > 35",
                null,
                15,
                Sort.by(Sort.Direction.ASC, Contact_._CID.getName())
        );
    }

    @Test
    void catchupContacts_case2() {
        clientCustomQuery.catchupContacts(null, 70, 12, null, 10);
        verify(contactRepository).findAll(arg1.capture(), arg2.capture());
        checkParams(
                "_CID <= 70 & changeOrder > 12",
                null,
                10,
                Sort.by(Sort.Direction.ASC, Contact_.changeOrder.getName())
        );
    }

    @Test
    void catchupContacts_case3() {
        clientCustomQuery.catchupContacts(null, null, null, 1, 0);
        verify(contactRepository).findAll(arg1.capture(), arg2.capture());
        checkParams(
                "stateOrder > 1",
                null,
                null,
                Sort.by(Sort.Direction.ASC, Contact_.stateOrder.getName())
        );
    }

    @Test
    void catchupContacts_case4() {
        clientCustomQuery.catchupContacts(15, 20, 1, 1, 0);
        verify(contactRepository).findAll(arg1.capture(), arg2.capture());
        checkParams(
                "_CID > 15 & _CID <= 20 & (changeOrder > 1 | stateOrder > 1)",
                sql -> {
                    System.out.println(sql);
                    assertTrue(sql.contains("(") && sql.contains(")"));
                    String substring = sql.substring(sql.indexOf('(') + 1, sql.lastIndexOf(')'));
                    assertThat(StringUtils.countOccurrencesOf(substring, " or ")).isEqualTo(1);
                    assertThat(StringUtils.countOccurrencesOf(substring, " and ")).isEqualTo(0);
                },
                null,
                Sort.unsorted()
        );
    }
}
